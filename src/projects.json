[
  {
    "title": "fullSend",
    "img": "https://www.turing.io/sites/default/files/styles/project_screenshot/public/project_screenshots/main_2.png?itok=a3KEGRGs",
    "overview": "This was a two week individual project during Module Three of the front end program at Turing. Project goals included creating a personal project using React, Redux, Router, and an external API in which a user is able to fulfill a need. Additionally, we were to use jest/enzyme to build a thorough test suite to help guide us during app development. Technologies used to to implement this project were the Strava API, MTB Project API, React, React-Router, React-Redux, Express, KnexJS, JSX, vanillaJS, and CSS, as well as Jest/Enzyme for the testing suite. The boilerplate repo used to build this app was constructed using create-react-app.",
    "goals": "I set out to build an app that would allow a user to keep track of their mountain bike rides. My inspiration comes from what I have done in the past to accomplish the same goal, which was achieved by just writing a note in my calendar. However, I almost never included where I rode, or any of the ride statistics from the day. With fullSend, a user is able to keep track of the date of their ride, what trail system they rode on, the difficulty of the trail, the location of the trail, as well as ride mileage and duration. They can also keep track of how much mileage they put on each of their bikes, their personal statistics for recent, year-to-date, and all-time rides. Lastly, they are able to view a todo list of trails they would like to ride in the future.  One of the main challenges was implementing the backend. The Strava API requires OAuth 2.0 in order to pull user information, so to accomplish this I implemented a hand-rolled express server with Strava OAuth. Additionally, I wanted users to be able to store their rides on the local server, so I added a Knex.js database to the express server to keep track of a user's rides.",
    "github": "https://github.com/patrickmc21/fullSend",
    "live": "http://fullsend.surge.sh/"
  },
  {
    "title": "SWapi-Box",
    "img": "https://www.turing.io/sites/default/files/styles/project_screenshot/public/project_screenshots/main_0.png?itok=sm_uIjAw",
    "overview": "This was a one week solo project during Module Three of the front end program at Turing. Project goals included handling multiple fetchs of the Star Wars API to bring in app content, as well as creating small, reusable React components. Additionally, we were to use jest/enzyme to build a thorough testing suite to help guide us during app development. An extension to implement React-Router was also an option. Technologies used to to implement this project were the StarWars API, React, React-Router, JSX, vanillaJS, and CSS, as well as Jest/Enzyme for the testing suite. The boilerplate repo used to build this app was constructed using create-react-app.",
    "goals": "We set out to build an app that would allow a user to view different sets of Star Wars information retrieved from the Star Wars api, including characters, vehicles, starships, and planets. Users can add a card to their favorites, which they can view in one location after visiting the favorites page. One of the main challenges was handling the chained fetch calls required to get the necessary information populated on the people and planet cards. This was our first dive into handing complex, asynchronous Javascript. Additionally, implementing React-router added some issues as I transitioned the app to add the new technology.",
    "github": "https://github.com/patrickmc21/swapi-box",
    "live": "http://starwarswikipm.surge.sh/"
  },
  {
    "title": "Centipede",
    "img": "https://www.turing.io/sites/default/files/styles/project_screenshot/public/project_screenshots/centipede.png?itok=Pgn930eS",
    "overview": "The gametime project allowed us to re-create a popular arcade game using CanvasJS. Objects in the game are created using Class constructor files, and each class should have its own testing file to verify functionality. The objective of the game is to progess through levels by eliminating all segments of a centipede. Points are accrued on destruction of a centipede segment, eliminating a spider object, and completing a level. Lives are lost when a centipede segment or a spider makes contact with the player. The game ends when all lives are used. Game makes use of a high score feature.",
    "goals": "",
    "github": "https://github.com/patrickmc21/game-time",
    "live": "http://kill-that-centipede.surge.sh/"
  },
  {
    "title": "Palette-Picker",
    "img": "https://www.turing.io/sites/default/files/styles/project_screenshot/public/project_screenshots/main_3.png?itok=5lfcWngA",
    "overview": "An application used generate color palettes, and save palettes to project folders. App is built on the front end using jQuery, JavaScript and CSS. Backend is build using Express and Knex. Continuous Integration provided by Travis CI. Test Suite build using Mocha/Chai. This was a one week individual project during module four of the frontend program at Turing. Project goals included creating a site that generated a random color palette, and allowed users to lock in colors, and save palettes to different project folders.",
    "goals": "",
    "github": "https://github.com/patrickmc21/palette-picker",
    "live": "https://palettepickerpat.herokuapp.com/"
  },
  {
    "title": "Weathrly",
    "img": "https://www.turing.io/sites/default/files/styles/project_screenshot/public/project_screenshots/rain-mock.png?itok=daZv7hCX",
    "overview": "Weathrly is a weather app built on the ReactJs framework. The motivation behind the layout was to present a user up to date weather info for any location they choose. We took forecast info for the curernt hour, the seven hour forecast, and the ten day forecast and overlayed it on vivid, high resolution images tied to the current condition to give the user a more visceral feel for the current weather conditions. Weathrly uses the Weather Underground API to retrieve current weather conditions and presents it to the user on a React based app. The app will take new users to a welcome screen where they can enter in their location, or if they are a returning user the app will take the user to their last searched location. The search bar makes use of a prefix-trie to give the user auto-complete functionality, and the auto-complete is pre-populated with a list of 1000 cities.",
    "goals": "",
    "github": "https://github.com/patrickmc21/weathrly",
    "live": "http://weathrly-pm.surge.sh/"
  }
]